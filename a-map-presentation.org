* The Life of a Clojure Expression

  A deep but skinny slice of Clojure internals

  John Hume\\
  @duelinmarkers

  Code excerpts have been edited for
  readability and to fit this screen.


* The Life of What Clojure Expression?

#+begin_src clojure
  (defn m [v] {:foo "bar" :baz v} )
  ;;          ^                 ^
  ;;          |____ this one ___|
#+end_src

* So really,
* The Life of a Certain Map-Literal Expression

  with minor variations:
#+begin_src clojure
  {:foo "bar" :baz 23}     ; compile-time constant

  {:a 1 :b 2 :c 3 :d 4     ; 9+ kvs
   :e 5 :f 6 :g 7 :h 8 :i v}
#+end_src

* High-level

  - Read
  - Analyze
  - Eval

* Read - clojure.core/read
#+begin_src clojure
  ;; clojure/core.clj
  (defn read
    ,,,
    ([stream ,,,]
     (clojure.lang.LispReader/read stream ,,,)))
#+end_src

* Read - LispReader
#+begin_src java
  // clojure/lang/LispReader.java
  macros['{'] = new MapReader();
  ,,,
  static class MapReader extends AFn {
    public Object invoke(Object reader, Object _) {
      PushbackReader r = (PushbackReader) reader;
      Object[] a = readDelimitedList('}', ,,,);
      if((a.length & 1) == 1)
        throw Util.runtimeException("Odd forms!? NO");
      return RT.map(a);
    }
  }
#+end_src

* Read - RT
#+begin_src java
  // clojure/lang/RT.java
  static public IPersistentMap map(Object... init){
    if(init == null)
      return PersistentArrayMap.EMPTY;
    else if(init.length <= 16)
      return PersistentArrayMap.createWithCheck(init);
    return PersistentHashMap.createWithCheck(init);
  }
#+end_src

* Read
#+begin_src java
  // clojure/lang/PersistentArrayMap.java
  static PersistentArrayMap createWithCheck(Object[] init){
   for(int i=0; i < init.length; i += 2) {
    for(int j=i+2; j < init.length; j += 2) {
     if(equalKey(init[i], init[j]))
      throw new IllegalArgumentException("Dupe:" + init[i]);
    }
   }
   return new PersistentArrayMap(init);
  }
#+end_src

* Analyze + Eval
#+begin_src java
  // clojure/lang/Compiler.java
  public static Object eval(Object form, boolean freshLoader) {
    ,,,
    form = macroexpand(form);
    if(form instanceof ISeq && Util.equals(RT.first(form), DO)) { ,,, }
    else if((form instanceof IType) ||
            (form instanceof IPersistentCollection
             && !(RT.first(form) instanceof Symbol
                  && ((Symbol) RT.first(form)).name.startsWith("def"))))
    {
      ObjExpr fexpr = (ObjExpr) analyze(C.EXPRESSION,
                                        RT.list(FN, PersistentVector.EMPTY, form),
                                        "eval" + RT.nextID());
      IFn fn = (IFn) fexpr.eval();
      return fn.invoke();
    } else {
      Expr expr = analyze(C.EVAL, form);
      return expr.eval();
    }
  }
#+end_src

* Analyze + Eval
#+begin_src java
  // clojure/lang/Compiler.java
  private static Expr analyze(C context, Object form, String name) {
    Class fclass = form.getClass();
    if(fclass == Symbol.class) { ,,, }
    ,,,
    else if(form instanceof IPersistentMap)
      return MapExpr.parse(context, (IPersistentMap) form);
  }
#+end_src

* Analyze + Eval
#+begin_src java
  public static class MapExpr implements Expr{
    // ...
    static public Expr parse(C context, IPersistentMap form) {
      IPersistentVector keyvals = PersistentVector.EMPTY;
      // elided constantness and uniqueness flags
      for(ISeq s = RT.seq(form); s != null; s = s.next()) {
        IMapEntry e = (IMapEntry) s.first();
        Expr k = analyze(context == C.EVAL ? context : C.EXPRESSION, e.key());
        Expr v = analyze(context == C.EVAL ? context : C.EXPRESSION, e.val());
        keyvals = (IPersistentVector) keyvals.cons(k);
        keyvals = (IPersistentVector) keyvals.cons(v);
        // elided constantness, uniqueness checks
      }
      Expr ret = new MapExpr(keyvals);
      // elided: have metadata? wrap in MetaExpr.
      // elided: non-unique constant keys? throw.
      // elided: ALL kvs constant? unpack into fresh map, wrap in ConstantExpr.
      return ret;
    }
  }
#+end_src

* Analyze + Eval
#+begin_src java
  public static class MapExpr implements Expr{
    // ...
    public Object eval() {
      Object[] ret = new Object[keyvals.count()];
      for(int i = 0; i < keyvals.count(); i++)
        ret[i] = ((Expr) keyvals.nth(i)).eval();
      return RT.map(ret);
    }
    // ...
  }
#+end_src
